---
title: Mastering Kadane's Algorithm
description: Learn how Kadane's Algorithm efficiently finds the maximum sum subarray, even with negative numbers.
---

## <Annotate>What is Kadane's Algorithm?</Annotate>

Kadane's Algorithm is a powerful technique to find the **maximum sum of a contiguous subarray** in a one-dimensional array. It runs in `O(n)` time, making it an optimal solution for problems involving subarray sums.

### <Annotate>How It Works</Annotate>

The algorithm uses two variables:
- **current_sum**: Tracks the sum of the current subarray.
- **max_sum**: Stores the maximum sum encountered so far.

At each step, it decides:
1. If the current element alone is greater than the sum of the ongoing subarray (`current_sum`), it starts a new subarray.
2. Otherwise, it continues adding the current element to the ongoing subarray.

### <Annotate>Handling Negative Numbers</Annotate>

Kadane's Algorithm efficiently handles arrays with negative numbers by dynamically resetting the `current_sum` when it falls below zero. This ensures:
- The subarray contributing to `max_sum` does not include unnecessary negative values.
- The algorithm adapts to the array's state, even when all numbers are negative, by selecting the **least negative single element** as the maximum sum.

### <Annotate>Why Kadane's Algorithm is Optimal</Annotate>

1. **Linear Time Complexity**: It traverses the array in a single pass.
2. **Space Efficiency**: Uses constant space, with no additional data structures required.
3. **Dynamic Decisions**: Ensures the optimal subarray is built without unnecessary calculations.

### <Annotate>Pseudo-Code and Implementation</Annotate>

<Tabs defaultValue="python" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="cpp">C++</TabsTrigger>
    <TabsTrigger value="python">Python</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
  </TabsList>

  <TabsContent value="cpp">
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    int kadane(const vector<int>& arr) {
        int max_sum = INT_MIN, current_sum = 0;

        for (int num : arr) {
            current_sum = max(num, current_sum + num);
            max_sum = max(max_sum, current_sum);
        }
        return max_sum;
    }

    int main() {
        vector<int> arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        cout << "Maximum Subarray Sum: " << kadane(arr) << endl;
        return 0;
    }
    ```
  </TabsContent>

  <TabsContent value="python">
    ```python
    def kadane(arr):
        max_sum = float('-inf')
        current_sum = 0

        for num in arr:
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)

        return max_sum

    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    print("Maximum Subarray Sum:", kadane(arr))
    ```
  </TabsContent>

  <TabsContent value="java">
    ```java
    public class Kadane {
        public static int kadane(int[] arr) {
            int maxSum = Integer.MIN_VALUE;
            int currentSum = 0;

            for (int num : arr) {
                currentSum = Math.max(num, currentSum + num);
                maxSum = Math.max(maxSum, currentSum);
            }
            return maxSum;
        }

        public static void main(String[] args) {
            int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
            System.out.println("Maximum Subarray Sum: " + kadane(arr));
        }
    }
    ```
  </TabsContent>
</Tabs>

### <Annotate>Example</Annotate>

Input: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`  
Output: `6` (Subarray: `[4, -1, 2, 1]`)

### <Annotate>Key Takeaway</Annotate>

Kadane's Algorithm's ability to dynamically reset the subarray when faced with negatives ensures it always finds the optimal solution. Its simplicity and efficiency make it a cornerstone of competitive programming and algorithmic problem-solving.

### <Annotate>Resources</Annotate>

`WIP`